% TODO outline how multiple applications share the ecovisor/api

Figure \ref{fig:system_design} illustrates our general system design approach
that simulates the ecovisor infrastructure and integrates it into the Mosaik
co-simulation environment while enabling SIL capabilities. The present design
can be categorized into two distinct parts, the simulation of the ecovisor, and
its interface to external applications, which are elaborated on in the
following.

\begin{figure}
    \centering
    \includegraphics[width=\linewidth]{figures/system_design}
    \caption{
        General System Design: The ecovisor infrastructure is simulated and
        integrated into the Mosaik co-simulation environment. SIL capabilities
        are enabled via an API Server and a Redis database, connecting the
        simulation environment and real applications in real-time.
    }
    \label{fig:system_design}
\end{figure}

\subsection{Simulation of the Ecovisor}
The simulation part of our approach is fully contained within the Mosaik
co-simulation environment. In Figure \ref{fig:system_design} this includes the
photo-voltaic (PV) module, the ecovisor and a consumer simulator. The consumer
and PV module simulators utilized in this context are the \texttt{mosaik-csv}
simulator, which is a component of the Mosaik ecosystem \cite{mosaik_ecosystem}.
This simulator is capable of simulating CSV datasets, and in the current
application, it is employed to simulate consumption data and recorded or
forecasted PV data. While our primary focus is to facilitate the integration of
external, non-simulated applications with our simulated ecovisor, we also
recognize the need to accommodate simulated consumers for more sophisticated
approaches that require additional data. Therefore, we aim to provide
flexibility in our system to meet a wide range of requirements. Because these
two components are designed to be minimal and replaceable, they each require a
controller agent that acts as a medium between the component and the simulated
ecovisor. The controller can be initialized with e.g. a power conversion factor
to allow for the use of different measurement units in the datasets, as the
standard power unit utilized in the ecovisor is kW.

The simulated ecovisor holds all necessary variables to enable the API in Table
\ref{table:ecovisor_api}. This includes instances of a simple battery and
energy-grid model. The Simple Battery model can be configured with a capacity
and an initial charge. For every simulation step, the charge is incremented by
the delta value. The Simple Energy-Grid model reads carbon information from a
CSV dataset, either every simulation step line by line, or for a specific point
in time.

Because the co-simulation runs in real or \enquote{wall-clock} time, the Mosaik
scenario needs to be executed with \texttt{rt\_factor=1}. Most models in our
approach are time-based and one simulation step always translates to one second
in real-time in our environment. Therefore, we only model power as energy,
making the standard unit for our approach kWs instead of kW.

The simulation of the ecovisor's virtual energy system is realized in Algorithm
\ref{alg:virtual_energy_system_simulation}. Like its original counterpart, the
system prioritizes the utilization of virtual solar power to fulfill energy
requirements in line 1. The power values are centered around consumption.
Because solar power is \emph{adding} power to the system, its value is negative.
Therefore, if \texttt{rest} is negative or zero in line 2, there is extra solar
power and the battery does not discharge in line 3. In cases where solar power
is insufficient, the virtual energy system resorts to battery to compensate for
the shortfall in lines 5 -- 9. The discharge rate of the battery then depends on
its maximum discharge rate, the charge level of the battery and the power that
is attempted to be drawn. If the battery can not supply sufficient power, the
remaining power is being drawn from the grid in line 12. Lines 13 -- 15 then
adjust the battery's charge. Finally lines 16 -- 18 determine the carbon
concentration for the simulation step.

Our approach does not implement a COP/Hypervisor. In the ecovisor, the COP
serves the primary purpose of granting containerized applications control over
their power consumption. Table \ref{table:ecovisor_api} shows that each
container can use the \texttt{set\_container\_powercap()} function to set their
power consumption limit. The ecovisor measures the power consumption of the
container using PowerAPI \cite{bourdon2013} and applies limits on resource
utilization using cgroups. The issue with PowerAPI is that it relies on
dedicated hardware equipped with sensors to collect raw data on software power
consumption. This collected data is then processed by a computational module
that utilizes a formula to \emph{estimate} the power consumption. A key
motivation behind the integration of the ecovisor into a co-simulation is to
create an affordable and accessible platform for researching and developing
carbon-aware applications. As power consumption measurement and control can vary
greatly depending on the research and development environment, we have chosen to
avoid implementing a specific strategy in order to allow for greater flexibility
and freedom.

\begin{figure}
    \removelatexerror
    \begin{algorithm}[H]
        \caption{Virtual Energy System Simulation}
        \label{alg:virtual_energy_system_simulation}
        $rest \gets consumption - solar$\;
        \eIf{$rest \leq 0$} {
            \tcp{excess (or equal) solar power}
            $b\_discharge\_rate \gets 0$\;
        }{
            \tcp{solar power is insufficient \mbox{$\rightarrow$ use battery}}
            $b\_discharge\_rate \gets \text{min}($\;
            \Indp
                $b\_max\_discharge,$\;
                $b\_charge\_level \cdot 3600,$\;
                $rest$\;
            \Indm
            $)$\;
            $rest \gets rest - b\_discharge\_rate$\;
        }
        \tcp{draw remaining power from grid}
        $grid\_power \gets b\_charge\_rate + rest$\;
        \tcp{adjust battery charge}
        $b.delta \gets b\_charge\_rate - b\_discharge\_rate$\;
        $b.step()$\;
        $b\_charge\_level \gets b.charge$\;
        \tcp{determine carbon concentration for step}
        $energy\_grid.step()$\;
        $grid\_carbon \gets energy\_grid.carbon$\;
        $total\_carbon \gets grid\_carbon \cdot grid\_power$\;
        \vspace{3mm}
    \end{algorithm}
\end{figure}

\subsection{Interface to External Applications}


To connect the Ecovisor-Model to a real workload-application, we exposed the API which is described in \cite{souza2023} to containerized workloads.we have tried to implement it in a way that is as close as possible to a real implementation in a cloud environment.
To achieve that, we implemented the Ecovisor-API from \cite{souza2023}, which can be seen in \ref{table:ecovisor_api}, into an FastAPI server \cite{fastapi}.
The API-Server is connected to a RedisDB\cite{redis}, which serves as a key-value store and links the API-Server to the Ecovisor-Model.
The Ecovisor-Model itself implements an Redis-Interface to read and write data from the RedisDB.
In the following three sections we will describe these three parts of the \textit{External Application Interface} in depth.
%TODO evtl. Gründe für den arch ansatz

\subsubsection{API-Server}
The API-Server exposes the Ecovisor-API to the "Workloads". It is implemented with the FastAPI Framework and utilizes the Uvicorn Web-Server \cite{uvicorn} to handle multiple clients accessing the API. Due to the ASGI (Asynchronous Server Gateway Interface) nature of the Web-Server, the module is started as a independent thread. The advantage of this, is that the server can handle multiple clients, which will be useful when multiple workloads will be connected to the simulation. On the other hand, the implementation into the system is more difficult, so that we decided to start the module independently. In earlier versions we tried to implement it inside of the Ecovisor-Model, but it would stops the execution of the simulation until the API-Server is stopped which renders the system unusable. This also enables the API-Server to be scaled independent from the Ecovisor-Model and the RedisDB. This may be helpful in bigger simulations with distributed infrastructure.
%We did not implement the\textit{tick} from the Ecovisor-API, since we do not use it at the moment.
%TODO evtl. tick

\subsubsection{RedisDB}
The RedisDB is a fast, in memory, key-value store for simple data-types. In our system, it is used to save and provide the data from within the Ecovisor-Model to the API-Server. To keep the operability of the simulation simple, the RedisDB is started as a Docker Container via the docker python library \cite{docker_python}, which implements the docker engine API into python. The container image we used is the redislabs rejson redis image \cite{RedisJSON}. This images extends the RedisDB image with the capability to process JSON values. The Redis-Container is started right at the beginng of the simulation, so that it is up and operational when the first data is available. After the end of the simulation, the container is stopped and deleted to keep the test environment free of remnants of t he simulation.
In general the database can easily be exchanged with any other database by adapting the Ecovisor-Redis-Interface in the Ecovisor-Model. This can be useful when simulation should be integrated
in a production grade cloud environment like kubernetes or openstack.


%Since the values are updated in one write atomicity is ensured, but due to the dataflow described in \ref{subsec:dataflow}
%atomicity isnot requierd to keep the values consistent.




\begin{figure}
	\removelatexerror
	\begin{algorithm}[H]
		\caption{Energy Data JSON structur}
		\label{alg:energy_JSON}
		\{\;
			$"solar\_power" : "0\: kW",$\;
			$"grid\_power" : "0\: kW",$\;
			$"grid\_carbon" : "0\: g*CO2/kW",$\;
			$"battery\_discharge\_rate" : "0\: kW",$\;
			$"battery\_charge\_level" : "0\: kWh"$\;
		\}
		\vspace{3mm}
	\end{algorithm}
\end{figure}

\begin{figure}
	\removelatexerror
	\begin{algorithm}[H]
		\caption{Container Power Cap JSON structur}
		\label{alg:container_JSON}
		\{\;
		$"Container\_ID\: 1" : "Power\: Cap\: 0\: kW",$\;
		$"Container\_ID\: 2" : "Power\: Cap\: 0\: kW",$\;
		$"Container\_ID\: n" : "Power\: Cap\: ...",$\;
		\}
		\vspace{3mm}
	\end{algorithm}
\end{figure}

\subsubsection{Ecovisor-Redis-Interface}
The interface towards the RedisDB is implemented within the Ecovisor-Model. To simplify the access, the Redis-py library \cite{Redis-py} is used. The Ecovisor-Model implements two methods, the \texttt{get\_redis\_updates()} and the \texttt{send\_redis\_update()}.

The \texttt{get\_redis\_update()} method is called at the beginning of the \texttt{step()} method in the Ecovisor-Model, which updates the simulation. It updates the values \texttt{battery\_discharge\_rate}, \texttt{battery\_charge\_level} and the \texttt{container\_power\_caps}. These values are used in the following "power" calculations in the Ecovisor-Model. To exchange the Data with the RedisDB, the data-structure shown in \ref{alg:energy_JSON} is used. To simplify the implementation, all values in \ref{alg:energy_JSON} are pulled from the RedisDB, but only the values named before are updated and used. Additionally the data-structure \ref{alg:container_JSON} is used to update the \texttt{container\_power\_cap} of the different workload applications.

the \texttt{send\_redis\_updates()} method is called at the end of the \texttt{step()} method and  publishes the updated values from the Ecovisor-Model. This includes data from the other part of the simulation which is accessible by the Ecovisor-Model.
The data is exchanged to the RedisDB with the data-structure shown in \ref{alg:energy_JSON} and made accessible to the workload application via the API-Server.

\subsubsection{Dataflow}
\label{subsec:dataflow}
\begin{figure}
    \centering
    \includegraphics[width=\linewidth]{figures/Dataflow.drawio.png}
    \caption{Data-flow between Ecovisor-Model and API Server}
    \label{fig:dataflow}
\end{figure}

In \ref{fig:dataflow}, the exchange of data between the API-Server and the Ecovisor-Model is visualized. As we can see, there ar two different data-streams, the upstream from, the API-Server to the Ecovisor-Model and the downstream, from the Ecovisor-Model to the API-Server.
Neither in the upstream nor in the downstream are values which are written in both endpoints. The setter methods from \ref{table:ecovisor_api}, which are accessed by the workload applications, only affect the values \texttt{container\_powercap}, \texttt{battery\_charge\_rate} and \texttt{battery\_max\_discharge}. These values are only read in the Ecovisor-Model. On the other side, the values written by the Ecovisor-Model are only accessible via the getter-methods of the API. This setting ensures the data-consistency, since none of the values can be written in parallel. Theoretically, the RedisDB supports atomic writes to ensure data-consistency \cite{redis}, but the feature is not needed in our setup.

To model the whole dataflow: In each step the Ecovisor-Model first gets the updates from the RedisDB, processes the data and then sends the updated data to the RedisDB, to make it accessible to the workload application. Updates send by the workload applications will be processed at the latest in the next call of the \texttt{step()} method. This process describes the whole data-flow between the Ecovisor-Model and the APi-Server and also the workload applications.



